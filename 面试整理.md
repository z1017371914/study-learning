

# 面试整理

[toc]



#### 死锁的条件，如何打破

* 互斥条件

* 循环等待 
* 不可剥夺 
* 请求与保持

​       

#### JMM

答：JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程有个工作内存，工作内存中存储了该线程以读/写变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。JMM是一个抽象概念，并不真实存在，它涵盖了缓存、寄存器以及其它硬件和编译器优化。



#### 如何创建线程池，队列都有哪些？拒绝策略都有哪些？任务过多时都是如何处理的



```java
public class MyThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(3, 5, 1L,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardPolicy());
//new ThreadPoolExecutor.AbortPolicy();
//new ThreadPoolExecutor.CallerRunsPolicy();
//new ThreadPoolExecutor.DiscardOldestPolicy();
//new ThreadPoolExecutor.DiscardPolicy();
        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}

```

* corePollSize: 基本线程数，如果当前线程数小于corePollSize,那么只要提交任务就创建，即使有空闲线程，

  ​						如果调用了线程池的prestartAllCoreThreads()方法会提前创建并启动所有的基本线程。

  

* runnableTaskQueue: 用于保存等待执行的任务的阻塞队列。

  * ArrayBlockingQueue: 是一个基于数组结构的有界阻塞队列，此队列按FIFO排序元素，

  * LinkedBlockingQueue: 吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。

  * SynchronousQueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作。

  * PriorityBlockingQueue: 一个具有优先级的无限阻塞队列。

    

* maximumPoolSize（线程池的最大数量）:线程池允许创建的最大线程数。如果队列满了，并且创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果了。
* ThreadFactory: 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。
* RejectedExecutionHandler:当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出的异常。
  * AbortPolicy: 直接抛出异常
  * CallerRunsPolicy: 只用调用者所在线程来运行任务。
  * DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。
  * DiscardPolicy: 不处理，丢弃掉。

* keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后，保持存活的时间。
* TimeUnit: 可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）



#### synchronized原理（double）jdk对synchronized做了哪些优化

答：monitorenter 指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitor必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorexit指令时，将会尝试获取对象所对应的monitor的所有权，即将尝试获得对象的锁。

偏向锁->轻量级锁->重量级锁



#### ReentrantLock



#### CAS ABA问题



#### [fail-fast 和 fail-safe](https://juejin.im/post/5cb683d6518825186d65402c)

####  HashMap的put、扩容原理，1.7和1.8的数据结构（double）



## 网络

#### [TCP粘包，为什么出现，如何解决](https://www.cnblogs.com/kex1n/p/6502002.html)

```

```

#### TCP如何实现消息可靠性、滑动窗口

  出错——通过校验和解决；

  丢包——超时重传+确认机制解决；

  失序、重复——通过TCP头部的序号解决；

####  [TCP三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809)



URG	紧急指针是否有效。为1，表示某一位需要被优先处理
ACK	确认号是否有效，一般置为1。
PSH	提示接收端应用程序立即从TCP缓冲区把数据读走。
RST	对方要求重新建立连接，复位。
SYN	请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN    	希望断开连接。

#### DNS



#### https原理、可以被攻击么？（double）



## 数据库事务

#### 事务的隔离级别、mysql和oracle默认是什么，都解决了什么问题（double）

read-uncommit

read-commit

repeatable-read

serizable

#### 事务的特性（double）

ACID

#### 快照读和当前读



#### 乐观锁、悲观锁、间隙锁、行锁、表锁的使用场景





#### B+树、聚簇索引和非聚簇索引（double）

#### mvcc（double）

#### redolog、undolog、binlog

#### 一个表没有索引的结构类型

#### 索引失效的场景

#### mysql都有哪些组件



## 中间件

RabbitMQ和kafka的架构（double）

如何保证消息的顺序性

为什么使用这个中间件（double）

Redis数据类型，底层数据结构（double）

缓存淘汰算法

缓存穿透、缓存击穿

缓存数据库双写（double）



## Spring

IOC和AOP的理解及原理（double）

Bean的生命周期（double）

自动注入方式有哪些，两个注解的区别

Spring MVC流程



## 微服务

分布式事务怎么做的（double）

CAP、BASE理论

如何实现一个RPC框架

服务熔断如何做的

令牌桶、漏桶算法

分布式id如何生成（double）



## JVM 

### 各个区域的内容（double）

* 方法区：主要存放类信息，常量池（static常量和static变量），编译后的代码（字节码）等信息
* 堆：初始化的对象，成员变量（那种非static的变量），所有的对象实例和数组都要在堆上分配。
* 栈: 栈的结构是栈桢组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是8大基础类型加上一个引用类型，所以还是一个指向地址的指针。
* 本地方法栈：主要为Native方法服务。
* 程序计数器：j记录当前线程执行的行号。



### GC root 有哪些？

```
（1）虚拟机（JVM）栈中引用对象

（2）方法区中的类静态属性引用对象

（3）方法区中常量引用的对象（final 的常量值）

（4）本地方法栈JNI的引用对象
```

### parallel scavenge 与parnew 区别

```
两者都是复制算法，都是并行处理，但是不同的是，paralel scavenge 可以设置最大gc停顿时间（-XX:MaxGCPauseMills）以及gc时间占比(-XX:GCTimeRatio)
```



常见OOM（double）

垃圾收集器、算法

类加载机制（double）

### 内存分配并发问题

```
1：对进行分配内存的动作进行同步处理-实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。

2：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程预先在JAVA堆中预先分配一小块内存，称为本地线程分配缓存（TLAB）。

哪个线程要分配内存，就在哪个线程的TLAB上进行分配。只有在TLAB用完并分配新的TLAB时，才需要加同步锁。虚拟机是否使用TLAB，可以通

过参数-XX:+/UseTLAB参数来设定。

3：直接在栈上分配，如果对象没有发生逃逸，那么对象将不会再堆上分配。对象随线程的销毁而销毁，垃圾回收的时间少，性能高，吞吐量高，响应时间也能提高。
```



新生代默认多少次晋升老年代

反射



## Mybatis



## JAVA基础



### [AQS](https://blog.csdn.net/mulinsen77/article/details/84583716)



>







