# 面试整理

[toc]

## Java基础

#### Collection 体系

![](https://tva1.sinaimg.cn/large/00831rSTly1gcp6oow9oej30tu0lsdi8.jpg)





#### 死锁的条件，如何打破

* 互斥条件

* 循环等待 
* 不可剥夺 
* 请求与保持

#### 重写的限制

```
重写规则之一：重写方法不能比被重写方法限制有更严格的访问级别。
（但是可以更广泛，比如父类方法是包访问权限，子类的重写方法是public访问权限。） 比如：Object类有个toString()方法，开始重写这个方法的时候我们总容易忘记public修饰符，
编译器当然不会放过任何教训我们 的机会。出错的原因就是：没有加任何访问修饰符的方法具有包访问权限，包访问权限比public当然要严格了，所以编译器会报错的。

重写规则之二： 参数列表必须与被重写方法的相同。
重写有个孪生的弟弟叫重载，也就是后面要出场的。如果子类方法的参数与父类对应的方法不同，那么就是你认错人了，那是重载，不是重写。
重写规则之三：返回类型必须与被重写方法的返回类型相同。
父类方法A：void eat(){} 子类方法B：int eat(){} 两者虽然参数相同，可是返回类型不同，所以不是重写。
父类方法A：int eat(){} 子类方法B：long eat(){} 返回类型虽然兼容父类，但是不同就是不同，所以不是重写。
重写规则之四：重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更少，更有限或者不抛出异常。
注意：这种限制只是针对检查异常，至于运行时异常RuntimeException及其子类不再这个限制之中。
重写规则之五： 不能重写被标识为final的方法。
重写规则之六：如果一个方法不能被继承，则不能重写它。如private方法
```

​       

#### JMM

答：JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程有个工作内存，工作内存中存储了该线程以读/写变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。JMM是一个抽象概念，并不真实存在，它涵盖了缓存、寄存器以及其它硬件和编译器优化。



#### 如何创建线程池，队列都有哪些？拒绝策略都有哪些？任务过多时都是如何处理的



```java
public class MyThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(3, 5, 1L,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardPolicy());
//new ThreadPoolExecutor.AbortPolicy();
//new ThreadPoolExecutor.CallerRunsPolicy();
//new ThreadPoolExecutor.DiscardOldestPolicy();
//new ThreadPoolExecutor.DiscardPolicy();
        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}

```

* corePollSize: 基本线程数，如果当前线程数小于corePollSize,那么只要提交任务就创建，即使有空闲线程，如果调用了线程池的prestartAllCoreThreads()方法会提前创建并启动所有的基本线程。

  

* runnableTaskQueue: 用于保存等待执行的任务的阻塞队列。

  * ArrayBlockingQueue: 是一个基于数组结构的有界阻塞队列，此队列按FIFO排序元素，

  * LinkedBlockingQueue: 吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。

  * SynchronousQueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作。

  * PriorityBlockingQueue: 一个具有优先级的无限阻塞队列。

    

* maximumPoolSize（线程池的最大数量）:线程池允许创建的最大线程数。如果队列满了，并且创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果了。
* ThreadFactory: 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。
* RejectedExecutionHandler:当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出的异常。
  * AbortPolicy: 直接抛出异常
  * CallerRunsPolicy: 只用调用者所在线程来运行任务。
  * DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。
  * DiscardPolicy: 不处理，丢弃掉。

* keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后，保持存活的时间。
* TimeUnit: 可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）

#### 线程中断相关

* thread.interrupt()  告诉线程可以中断了 , 线程中的很多操作 join sleep wait 都要
* thread.isInterrupted() true 或者false
* thread.interrupted() 复位

#### synchronized原理（double）jdk对synchronized做了哪些优化

答：monitorenter 指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitor必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorexit指令时，将会尝试获取对象所对应的monitor的所有权，即将尝试获得对象的锁。

偏向锁->轻量级锁->重量级锁



#### ReentrantLock



#### CAS ABA问题



#### [fail-fast 和 fail-safe](https://juejin.im/post/5cb683d6518825186d65402c)

####  HashMap的put、扩容原理，1.7和1.8的数据结构（double）

[AQS](https://blog.csdn.net/mulinsen77/article/details/84583716)

[ConcurrentHashMap](https://mp.weixin.qq.com/s/AixdbEiXf3KfE724kg2YIw)



## 网络

#### [TCP粘包，为什么出现，如何解决](https://www.cnblogs.com/kex1n/p/6502002.html)

```

```

#### TCP如何实现消息可靠性、滑动窗口

  出错——通过校验和解决；

  丢包——超时重传+确认机制解决；

  失序、重复——通过TCP头部的序号解决；

####  [TCP三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809)



URG	紧急指针是否有效。为1，表示某一位需要被优先处理
ACK	确认号是否有效，一般置为1。
PSH	提示接收端应用程序立即从TCP缓冲区把数据读走。
RST	对方要求重新建立连接，复位。
SYN	请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN    	希望断开连接。

#### DNS



#### https原理、可以被攻击么？（double）



## Mysql数据库事务

#### SQL优化

```
数据库调优这一块说一下，这里的话优先通过show query log去看sql执行情况，然后再根据sql的索引调优，如果explain的结果实在是不满意而你又知道哪个索引可以提升效率，可以偷偷的使用force index
```



#### 事务的隔离级别、mysql和oracle默认是什么，都解决了什么问题（double）

read-uncommit

read-commit

repeatable-read

serizable

#### 事务的特性（double）

ACID

#### 快照读和当前读



#### 乐观锁、悲观锁、间隙锁、行锁、表锁的使用场景





#### B+树、聚簇索引和非聚簇索引（double）

> 主键就是聚簇索引，没有主键，用6个字节的rowId 创建一个聚簇索引

#### mvcc（double）

#### redolog、undolog、binlog

#### 一个表没有索引的结构类型

#### 索引失效的场景

> 数据量 数据库版本都有关系，最终是优化器（）说了算

>1. 模糊查询 %like
>2. 索引列参与计算,使用了函数
>3. 非最左前缀顺序
>4. where对null判断
>5. where不等于
>6. or操作有至少一个字段没有索引
>7. 需要回表的查询结果集过大（超过配置的范围）
>8. <> !=   not in 不一定 用不到
>9. 

#### mysql都有哪些组件



### 事务的基本要素

> (1)原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行 (2)一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。 (3)隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。 (4)持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。



### 事务的并发问题

> (1)脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
>
>  (2)不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
>
>  (3)幻读：A事务读取了B事务已经提交的新增数据。注意和不可重复读的区别，这里是新增，不可重复读是更改（或删除）。

## 中间件

RabbitMQ和kafka的架构（double）

如何保证消息的顺序性

为什么使用这个中间件（double）

Redis数据类型，底层数据结构（double）

缓存淘汰算法

缓存穿透、缓存击穿

缓存数据库双写（double）



## Spring

IOC和AOP的理解及原理（double）

### Bean的生命周期（double）



自动注入方式有哪些，两个注解的区别

Spring MVC流程

```java
//1.客户端（浏览器）发送请求，直接请求到 DispatcherServlet。
//2.DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。
解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。
HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。
处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。
ViewResolver 会根据逻辑 View 查找实际的 View。
DispaterServlet 把返回的 Model 传给 View（视图渲染）。
把 View 返回给请求者（浏览器）
```

### [filter Intepreter AOP](https://www.jianshu.com/p/53ec69f1236e)





![](https://tva1.sinaimg.cn/large/00831rSTly1gctr3o7jekj30re05caau.jpg)



```

```



## 微服务

分布式事务怎么做的（double）

CAP、BASE理论

如何实现一个RPC框架

服务熔断如何做的

令牌桶、漏桶算法

分布式id如何生成（double）



## JVM  

### 各个区域的内容（double）

* 方法区：主要存放类信息，常量池（static常量和static变量），编译后的代码（字节码）等信息
* 堆：初始化的对象，成员变量（那种非static的变量），所有的对象实例和数组都要在堆上分配。
* 栈: 栈的结构是栈桢组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是8大基础类型加上一个引用类型，所以还是一个指向地址的指针。
* 本地方法栈：主要为Native方法服务。
* 程序计数器：j记录当前线程执行的行号。



### GC root 有哪些？

```
（1）虚拟机（JVM）栈中引用对象

（2）方法区中的类静态属性引用对象

（3）方法区中常量引用的对象（final 的常量值）

（4）本地方法栈JNI的引用对象
```

### parallel scavenge 与parnew 区别

```java
两者都是复制算法，都是并行处理，但是不同的是，paralel scavenge 可以设置最大gc停顿时间（-XX:MaxGCPauseMills）以及gc时间占比(-XX:GCTimeRatio)
```

常见OOM（double）

垃圾收集器、算法

类加载机制（double）

### 内存分配并发问题

```
1：对进行分配内存的动作进行同步处理-实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。

2：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程预先在JAVA堆中预先分配一小块内存，称为本地线程分配缓存（TLAB）。

哪个线程要分配内存，就在哪个线程的TLAB上进行分配。只有在TLAB用完并分配新的TLAB时，才需要加同步锁。虚拟机是否使用TLAB，可以通

过参数-XX:+/UseTLAB参数来设定。

3：直接在栈上分配，如果对象没有发生逃逸，那么对象将不会再堆上分配。对象随线程的销毁而销毁，垃圾回收的时间少，性能高，吞吐量高，响应时间也能提高。
```



新生代默认多少次晋升老年代

反射

### JVM 调优

#### jps & jinfo  进程和参数

```java
 jps 查看 pid

 jinfo flag pid

 jinfo flag UseG1GC PID
   
 实时修改某个进程中的JVM参数的值： jinf -flag name=value PID {manageable}
```



####  jstat 类和gc状态

```
jstat -class pid 1000 10 // 每1秒输出10次 类加载信息
jstat -gc 60356 1000 10  //  查看
```

#### jstack 查看线程堆栈信息 

```
jstack pid // 如果线程发生问题了，方便排查    查看死锁信息

```

![](https://tva1.sinaimg.cn/large/0082zybply1gc8oa2u9ybj30w70enwtl.jpg)

#### jmap 生成堆内存快照

```
jmap -heap pid  在线看
jmap -dmup:format=b,file=heap.hprof PID
```

2C 4G 生产环境OOM ---> 在发生OOM的时候，能够把堆内存的信息导出来，打印？

​         堆信息----> 是什么样的对象占用的内存空间比较大

#### 可视化工具 本质也是对命令行的封装

  下面两个事jdk自带的

* jconsole 

* jvisualvm 

  两者功能有重叠，各有千秋。

* 阿里开源的 arthas

* MAT  memoryAnalyzer  (可以分析heap.hprof文件) eclipse

  

（1）堆使用----OOM->排查哪个对象占用对象大

​           分析 heap文件

（2）垃圾回收  查看日志

​         ![](https://tva1.sinaimg.cn/large/0082zybply1gc8r4zskryj30j601x0td.jpg)



![](https://tva1.sinaimg.cn/large/0082zybply1gca67hbkbmj312x0nlk18.jpg)

  



## Mybatis



## JAVA基础



### 



## Zookeeper

### CAP

>一个分布式系统不可能同时满足以下三种,一致性（C:Consistency）,可用性（A:Available）,分区容错性（P:Partition Tolerance）. 在此ZooKeeper保证的是CP，ZooKeeper不能保证每次服务请求的可用性，在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。 另外在进行leader选举时集群都是不可用，所以说，ZooKeeper不能保证服务可用性。（Base理论CA强一致性和最终一致性）

### ZAB协议

paxo raft zab

> ZAB协议包括两种基本的模式：崩溃恢复和消息广播。当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。 当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。

### 选举算法和流程

> FastLeaderElection(默认提供的选举算法): 目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下： (1)服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。 (2)服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。 (3)服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为leader，服务器1,2成为follower。 (4)服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为follower。 (5)服务器5启动，后面的逻辑同服务器4成为follower。







